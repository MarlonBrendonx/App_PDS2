{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/home/user/Documentos/Git/App_PDS2/node_modules/react-native-text-ticker/index.js\";\nvar _excluded = [\"style\", \"children\", \"repeatSpacer\", \"scroll\", \"shouldAnimateTreshold\", \"disabled\", \"isRTL\"];\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { PureComponent } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Text from \"react-native-web/dist/exports/Text\";\nimport View from \"react-native-web/dist/exports/View\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nvar UIManager = NativeModules.UIManager;\nexport var TextTickAnimationType = Object.freeze({\n  auto: 'auto',\n  scroll: 'scroll',\n  bounce: 'bounce'\n});\n\nvar TextMarquee = function (_PureComponent) {\n  _inherits(TextMarquee, _PureComponent);\n\n  var _super = _createSuper(TextMarquee);\n\n  function TextMarquee(props) {\n    var _this;\n\n    _classCallCheck(this, TextMarquee);\n\n    _this = _super.call(this, props);\n    _this.animatedValue = new Animated.Value(0);\n    _this.distance = null;\n    _this.textRef = null;\n    _this.containerRef = null;\n    _this.state = {\n      animating: false,\n      contentFits: true,\n      shouldBounce: false,\n      isScrolling: false\n    };\n\n    _this.makeCancelable = function (promise) {\n      var cancel = function cancel() {};\n\n      var wrappedPromise = new Promise(function (resolve, reject) {\n        cancel = function cancel() {\n          resolve = null;\n          reject = null;\n        };\n\n        promise.then(function (value) {\n          if (resolve) {\n            resolve(value);\n          }\n        }, function (error) {\n          if (reject) {\n            reject(error);\n          }\n        });\n      });\n      wrappedPromise.cancel = cancel;\n      return wrappedPromise;\n    };\n\n    _this.startAnimation = function () {\n      if (_this.state.animating) {\n        return;\n      }\n\n      _this.start();\n    };\n\n    _this.animateScroll = function () {\n      var _this$props = _this.props,\n          duration = _this$props.duration,\n          marqueeDelay = _this$props.marqueeDelay,\n          loop = _this$props.loop,\n          isInteraction = _this$props.isInteraction,\n          useNativeDriver = _this$props.useNativeDriver,\n          repeatSpacer = _this$props.repeatSpacer,\n          easing = _this$props.easing,\n          children = _this$props.children,\n          scrollSpeed = _this$props.scrollSpeed,\n          onMarqueeComplete = _this$props.onMarqueeComplete,\n          isRTL = _this$props.isRTL;\n\n      _this.setTimeout(function () {\n        var scrollToValue = (isRTL != null ? isRTL : I18nManager.isRTL) ? _this.textWidth + repeatSpacer : -_this.textWidth - repeatSpacer;\n\n        if (!isNaN(scrollToValue)) {\n          Animated.timing(_this.animatedValue, {\n            toValue: scrollToValue,\n            duration: duration || _this.textWidth * scrollSpeed,\n            easing: easing,\n            isInteraction: isInteraction,\n            useNativeDriver: useNativeDriver\n          }).start(function (_ref) {\n            var finished = _ref.finished;\n\n            if (finished) {\n              if (onMarqueeComplete) {\n                onMarqueeComplete();\n              }\n\n              if (loop) {\n                _this.animatedValue.setValue(0);\n\n                _this.animateScroll();\n              }\n            }\n          });\n        } else {\n          _this.start();\n        }\n      }, marqueeDelay);\n    };\n\n    _this.animateBounce = function () {\n      var _this$props2 = _this.props,\n          duration = _this$props2.duration,\n          marqueeDelay = _this$props2.marqueeDelay,\n          loop = _this$props2.loop,\n          isInteraction = _this$props2.isInteraction,\n          useNativeDriver = _this$props2.useNativeDriver,\n          easing = _this$props2.easing,\n          bounceSpeed = _this$props2.bounceSpeed,\n          bouncePadding = _this$props2.bouncePadding,\n          bounceDelay = _this$props2.bounceDelay,\n          isRTL = _this$props2.isRTL;\n      var rtl = isRTL != null ? isRTL : I18nManager.isRTL;\n      var bounceEndPadding = rtl ? bouncePadding == null ? void 0 : bouncePadding.left : bouncePadding == null ? void 0 : bouncePadding.right;\n      var bounceStartPadding = rtl ? bouncePadding == null ? void 0 : bouncePadding.right : bouncePadding == null ? void 0 : bouncePadding.left;\n\n      _this.setTimeout(function () {\n        Animated.sequence([Animated.timing(_this.animatedValue, {\n          toValue: rtl ? _this.distance + (bounceEndPadding != null ? bounceEndPadding : 10) : -_this.distance - (bounceEndPadding != null ? bounceEndPadding : 10),\n          duration: duration || _this.distance * bounceSpeed,\n          easing: easing,\n          isInteraction: isInteraction,\n          useNativeDriver: useNativeDriver\n        }), Animated.timing(_this.animatedValue, {\n          toValue: rtl ? -(bounceStartPadding != null ? bounceStartPadding : 10) : bounceStartPadding != null ? bounceStartPadding : 10,\n          duration: duration || _this.distance * bounceSpeed,\n          easing: easing,\n          isInteraction: isInteraction,\n          useNativeDriver: useNativeDriver,\n          delay: bounceDelay\n        })]).start(function (_ref2) {\n          var finished = _ref2.finished;\n\n          if (finished) {\n            _this.hasFinishedFirstLoop = true;\n          }\n\n          if (loop) {\n            _this.animateBounce();\n          }\n        });\n      }, _this.hasFinishedFirstLoop ? bounceDelay > 0 ? bounceDelay : 0 : marqueeDelay);\n    };\n\n    _this.start = function _callee2() {\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _this.setState({\n                animating: true\n              });\n\n              _this.setTimeout(function _callee() {\n                var onScrollStart;\n                return _regeneratorRuntime.async(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return _regeneratorRuntime.awrap(_this.calculateMetrics());\n\n                      case 2:\n                        if (!_this.state.contentFits) {\n                          onScrollStart = _this.props.onScrollStart;\n\n                          if (onScrollStart && typeof onScrollStart === \"function\") {\n                            onScrollStart();\n                          }\n\n                          if (_this.props.animationType === 'auto') {\n                            if (_this.state.shouldBounce && _this.props.bounce) {\n                              _this.animateBounce();\n                            } else {\n                              _this.animateScroll();\n                            }\n                          } else if (_this.props.animationType === 'bounce') {\n                            _this.animateBounce();\n                          } else if (_this.props.animationType === 'scroll') {\n                            _this.animateScroll();\n                          }\n                        }\n\n                      case 3:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              }, 100);\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.invalidateMetrics = function () {\n      _this.distance = null;\n\n      _this.setState({\n        contentFits: true\n      });\n    };\n\n    _this.scrollBegin = function () {\n      _this.setState({\n        isScrolling: true\n      });\n\n      _this.animatedValue.setValue(0);\n    };\n\n    _this.scrollEnd = function () {\n      var marqueeDelay = _this.props.marqueeDelay;\n\n      _this.setTimeout(function () {\n        _this.setState({\n          isScrolling: false\n        });\n\n        _this.start();\n      }, marqueeDelay >= 0 ? marqueeDelay : 3000);\n    };\n\n    _this.resetScroll = function () {\n      _this.scrollBegin();\n\n      _this.scrollEnd();\n    };\n\n    _this.calculateMetricsPromise = null;\n    return _this;\n  }\n\n  _createClass(TextMarquee, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.invalidateMetrics();\n      var _this$props3 = this.props,\n          disabled = _this$props3.disabled,\n          marqueeDelay = _this$props3.marqueeDelay,\n          marqueeOnMount = _this$props3.marqueeOnMount;\n\n      if (!disabled && marqueeOnMount) {\n        this.startAnimation(marqueeDelay);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.children !== prevProps.children) {\n        this.resetScroll();\n      } else if (this.props.disabled !== prevProps.disabled) {\n        if (!this.props.disabled && this.props.marqueeOnMount) {\n          this.startAnimation(this.props.marqueeDelay);\n        } else if (this.props.disabled) {\n          if (this.calculateMetricsPromise !== null) {\n            this.calculateMetricsPromise.cancel();\n            this.calculateMetricsPromise = null;\n          }\n\n          this.stopAnimation();\n          this.clearTimeout();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.calculateMetricsPromise !== null) {\n        this.calculateMetricsPromise.cancel();\n        this.calculateMetricsPromise = null;\n      }\n\n      this.stopAnimation();\n      this.clearTimeout();\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation() {\n      this.animatedValue.setValue(0);\n      this.setState({\n        animating: false,\n        shouldBounce: false\n      });\n    }\n  }, {\n    key: \"calculateMetrics\",\n    value: function calculateMetrics() {\n      var _this2 = this;\n\n      var shouldAnimateTreshold;\n      return _regeneratorRuntime.async(function calculateMetrics$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              shouldAnimateTreshold = this.props.shouldAnimateTreshold;\n              this.calculateMetricsPromise = this.makeCancelable(new Promise(function _callee4(resolve, reject) {\n                var measureWidth, _await$Promise$all, _await$Promise$all2, containerWidth, textWidth;\n\n                return _regeneratorRuntime.async(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _context4.prev = 0;\n\n                        measureWidth = function measureWidth(node) {\n                          return new Promise(function _callee3(resolve, reject) {\n                            var nodeHandle;\n                            return _regeneratorRuntime.async(function _callee3$(_context3) {\n                              while (1) {\n                                switch (_context3.prev = _context3.next) {\n                                  case 0:\n                                    nodeHandle = findNodeHandle(node);\n\n                                    if (!nodeHandle) {\n                                      _context3.next = 5;\n                                      break;\n                                    }\n\n                                    UIManager.measure(nodeHandle, function (x, y, w) {\n                                      return resolve(w);\n                                    });\n                                    _context3.next = 6;\n                                    break;\n\n                                  case 5:\n                                    return _context3.abrupt(\"return\", reject('nodehandle_not_found'));\n\n                                  case 6:\n                                  case \"end\":\n                                    return _context3.stop();\n                                }\n                              }\n                            }, null, null, null, Promise);\n                          });\n                        };\n\n                        _context4.next = 4;\n                        return _regeneratorRuntime.awrap(Promise.all([measureWidth(_this2.containerRef), measureWidth(_this2.textRef)]));\n\n                      case 4:\n                        _await$Promise$all = _context4.sent;\n                        _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n                        containerWidth = _await$Promise$all2[0];\n                        textWidth = _await$Promise$all2[1];\n                        _this2.containerWidth = containerWidth;\n                        _this2.textWidth = textWidth;\n                        _this2.distance = textWidth - containerWidth + shouldAnimateTreshold;\n                        resolve({\n                          contentFits: _this2.distance <= 1,\n                          shouldBounce: _this2.distance < _this2.containerWidth / 8\n                        });\n                        _context4.next = 17;\n                        break;\n\n                      case 14:\n                        _context4.prev = 14;\n                        _context4.t0 = _context4[\"catch\"](0);\n                        console.warn('react-native-text-ticker: could not calculate metrics', _context4.t0);\n\n                      case 17:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, null, null, [[0, 14]], Promise);\n              }));\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(this.calculateMetricsPromise.then(function (result) {\n                _this2.setState({\n                  contentFits: result.contentFits,\n                  shouldBounce: result.shouldBounce\n                });\n\n                return [];\n              }));\n\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"clearTimeout\",\n    value: function (_clearTimeout) {\n      function clearTimeout() {\n        return _clearTimeout.apply(this, arguments);\n      }\n\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n\n      return clearTimeout;\n    }(function () {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n    })\n  }, {\n    key: \"setTimeout\",\n    value: function (_setTimeout) {\n      function setTimeout(_x) {\n        return _setTimeout.apply(this, arguments);\n      }\n\n      setTimeout.toString = function () {\n        return _setTimeout.toString();\n      };\n\n      return setTimeout;\n    }(function (fn) {\n      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.clearTimeout();\n      this.timer = setTimeout(fn, time);\n    })\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props4 = this.props,\n          style = _this$props4.style,\n          children = _this$props4.children,\n          repeatSpacer = _this$props4.repeatSpacer,\n          scroll = _this$props4.scroll,\n          shouldAnimateTreshold = _this$props4.shouldAnimateTreshold,\n          disabled = _this$props4.disabled,\n          isRTL = _this$props4.isRTL,\n          props = _objectWithoutProperties(_this$props4, _excluded);\n\n      var _this$state = this.state,\n          animating = _this$state.animating,\n          contentFits = _this$state.contentFits,\n          isScrolling = _this$state.isScrolling;\n      var additionalContainerStyle = {\n        flex: shouldAnimateTreshold ? 1 : undefined\n      };\n      var animatedText = disabled ? null : React.createElement(ScrollView, {\n        ref: function ref(c) {\n          return _this3.containerRef = c;\n        },\n        horizontal: true,\n        scrollEnabled: scroll ? !this.state.contentFits : false,\n        scrollEventThrottle: 16,\n        onScrollBeginDrag: this.scrollBegin,\n        onScrollEndDrag: this.scrollEnd,\n        showsHorizontalScrollIndicator: false,\n        style: [StyleSheet.absoluteFillObject, (isRTL != null ? isRTL : I18nManager.isRTL) && {\n          flexDirection: 'row-reverse'\n        }],\n        display: animating ? 'flex' : 'none',\n        onContentSizeChange: function onContentSizeChange() {\n          return _this3.calculateMetrics();\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 325,\n          columnNumber: 7\n        }\n      }, React.createElement(Animated.Text, _extends({\n        ref: function ref(c) {\n          return _this3.textRef = c;\n        },\n        numberOfLines: 1\n      }, props, {\n        style: [style, {\n          transform: [{\n            translateX: this.animatedValue\n          }],\n          width: null\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 337,\n          columnNumber: 9\n        }\n      }), this.props.children), !contentFits && !isScrolling ? React.createElement(View, {\n        style: {\n          paddingLeft: repeatSpacer\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 13\n        }\n      }, React.createElement(Animated.Text, _extends({\n        numberOfLines: 1\n      }, props, {\n        style: [style, {\n          transform: [{\n            translateX: this.animatedValue\n          }],\n          width: null\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 347,\n          columnNumber: 13\n        }\n      }), this.props.children)) : null);\n      return React.createElement(View, {\n        style: [styles.container, additionalContainerStyle],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 358,\n          columnNumber: 7\n        }\n      }, React.createElement(Text, _extends({}, props, {\n        numberOfLines: 1,\n        style: [style, {\n          opacity: !disabled && animating ? 0 : 1\n        }],\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 359,\n          columnNumber: 9\n        }\n      }), this.props.children), animatedText);\n    }\n  }]);\n\n  return TextMarquee;\n}(PureComponent);\n\nTextMarquee.defaultProps = {\n  style: {},\n  loop: true,\n  bounce: true,\n  scroll: true,\n  marqueeOnMount: true,\n  marqueeDelay: 0,\n  isInteraction: true,\n  useNativeDriver: true,\n  repeatSpacer: 50,\n  easing: Easing.ease,\n  animationType: 'auto',\n  bounceSpeed: 50,\n  scrollSpeed: 150,\n  bouncePadding: undefined,\n  bounceDelay: 0,\n  shouldAnimateTreshold: 0,\n  disabled: false,\n  isRTL: undefined\n};\nexport { TextMarquee as default };\nvar styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden'\n  }\n});","map":{"version":3,"sources":["/home/user/Documentos/Git/App_PDS2/node_modules/react-native-text-ticker/index.js"],"names":["React","PureComponent","UIManager","NativeModules","TextTickAnimationType","Object","freeze","auto","scroll","bounce","TextMarquee","props","animatedValue","Animated","Value","distance","textRef","containerRef","state","animating","contentFits","shouldBounce","isScrolling","makeCancelable","promise","cancel","wrappedPromise","Promise","resolve","reject","then","value","error","startAnimation","start","animateScroll","duration","marqueeDelay","loop","isInteraction","useNativeDriver","repeatSpacer","easing","children","scrollSpeed","onMarqueeComplete","isRTL","setTimeout","scrollToValue","I18nManager","textWidth","isNaN","timing","toValue","finished","setValue","animateBounce","bounceSpeed","bouncePadding","bounceDelay","rtl","bounceEndPadding","left","right","bounceStartPadding","sequence","delay","hasFinishedFirstLoop","setState","calculateMetrics","onScrollStart","animationType","invalidateMetrics","scrollBegin","scrollEnd","resetScroll","calculateMetricsPromise","disabled","marqueeOnMount","prevProps","stopAnimation","clearTimeout","shouldAnimateTreshold","measureWidth","node","nodeHandle","findNodeHandle","measure","x","y","w","all","containerWidth","console","warn","result","timer","fn","time","style","additionalContainerStyle","flex","undefined","animatedText","c","StyleSheet","absoluteFillObject","flexDirection","transform","translateX","width","paddingLeft","styles","container","opacity","defaultProps","Easing","ease","create","overflow"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react'\nimport {\n  Animated,\n  Easing,\n  StyleSheet,\n  Text,\n  View,\n  ScrollView,\n  NativeModules,\n  findNodeHandle,\n  I18nManager\n} from 'react-native'\n\nconst { UIManager } = NativeModules\n\nexport const TextTickAnimationType = Object.freeze({\n  auto: 'auto',\n  scroll: 'scroll',\n  bounce: 'bounce'\n})\n\nexport default class TextMarquee extends PureComponent {\n  static defaultProps = {\n    style:             {},\n    loop:              true,\n    bounce:            true,\n    scroll:            true,\n    marqueeOnMount:    true,\n    marqueeDelay:      0,\n    isInteraction:     true,\n    useNativeDriver:   true,\n    repeatSpacer:      50,\n    easing:            Easing.ease,\n    animationType:     'auto',\n    bounceSpeed:       50,\n    scrollSpeed:       150,\n    bouncePadding:     undefined,\n    bounceDelay: 0,\n    shouldAnimateTreshold: 0,\n    disabled:          false,\n    isRTL:             undefined\n  }\n\n  animatedValue = new Animated.Value(0)\n  distance = null\n  textRef = null\n  containerRef = null\n\n  state = {\n    animating:    false,\n    contentFits:  true,\n    shouldBounce: false,\n    isScrolling:  false\n  }\n\n  constructor(props) {\n    super(props);\n    this.calculateMetricsPromise = null\n  }\n  \n  componentDidMount() {\n    this.invalidateMetrics()\n    const { disabled, marqueeDelay, marqueeOnMount } = this.props\n    if (!disabled && marqueeOnMount) {\n      this.startAnimation(marqueeDelay)\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    if (this.props.children !== prevProps.children) {\n      this.resetScroll()\n    } else if (this.props.disabled !== prevProps.disabled) {\n      if (!this.props.disabled && this.props.marqueeOnMount) {\n        this.startAnimation(this.props.marqueeDelay)\n      } else if (this.props.disabled) {\n        // Cancel any promises\n        if (this.calculateMetricsPromise !== null) {\n          this.calculateMetricsPromise.cancel()\n          this.calculateMetricsPromise = null\n        }\n        this.stopAnimation()\n        this.clearTimeout()\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    // Cancel promise to stop setState after unmount\n    if (this.calculateMetricsPromise !== null) {\n      this.calculateMetricsPromise.cancel()\n      this.calculateMetricsPromise = null\n    }\n    this.stopAnimation()\n    // always stop timers when unmounting, common source of crash\n    this.clearTimeout()\n  }\n\n  makeCancelable = (promise) => {\n    let cancel = () => {}\n    const wrappedPromise = new Promise((resolve, reject) => {\n      cancel = () => {\n        resolve = null\n        reject = null\n      };\n      promise.then(\n        value => {\n          if (resolve) {\n            resolve(value)\n          }\n        }, \n        error => {\n          if (reject) {\n            reject(error)\n          }\n        }\n      );\n    });\n    wrappedPromise.cancel = cancel\n    return wrappedPromise\n  };\n\n  startAnimation = () => {\n    if (this.state.animating) {\n      return\n    }\n    this.start()\n  }\n\n  animateScroll = () => {\n    const {\n      duration,\n      marqueeDelay,\n      loop,\n      isInteraction,\n      useNativeDriver,\n      repeatSpacer,\n      easing,\n      children,\n      scrollSpeed,\n      onMarqueeComplete,\n      isRTL\n    } = this.props\n    this.setTimeout(() => {\n      const scrollToValue = isRTL ?? I18nManager.isRTL ? this.textWidth + repeatSpacer : -this.textWidth - repeatSpacer\n      if(!isNaN(scrollToValue)) {\n        Animated.timing(this.animatedValue, {\n          toValue:         scrollToValue,\n          duration:        duration || this.textWidth * scrollSpeed,\n          easing:          easing,\n          isInteraction:   isInteraction,\n          useNativeDriver: useNativeDriver\n        }).start(({ finished }) => {\n          if (finished) {\n            if (onMarqueeComplete) {\n              onMarqueeComplete()\n            }\n            if (loop) {\n              this.animatedValue.setValue(0)\n              this.animateScroll()\n            }\n          }\n        })} else {\n          this.start()\n        }\n    }, marqueeDelay)\n  }\n\n  animateBounce = () => {\n    const {duration, marqueeDelay, loop, isInteraction, useNativeDriver, easing, bounceSpeed, bouncePadding, bounceDelay, isRTL} = this.props\n    const rtl = isRTL ?? I18nManager.isRTL;\n    const bounceEndPadding = rtl ? bouncePadding?.left : bouncePadding?.right;\n    const bounceStartPadding = rtl ? bouncePadding?.right : bouncePadding?.left;\n    this.setTimeout(() => {\n      Animated.sequence([\n        Animated.timing(this.animatedValue, {\n          toValue:         rtl ? this.distance + (bounceEndPadding ?? 10) : -this.distance - (bounceEndPadding ?? 10),\n          duration:        duration || (this.distance) * bounceSpeed,\n          easing:          easing,\n          isInteraction:   isInteraction,\n          useNativeDriver: useNativeDriver\n        }),\n        Animated.timing(this.animatedValue, {\n          toValue:         rtl ? -(bounceStartPadding ?? 10) : bounceStartPadding ?? 10,\n          duration:        duration || (this.distance) * bounceSpeed,\n          easing:          easing,\n          isInteraction:   isInteraction,\n          useNativeDriver: useNativeDriver,\n          delay: bounceDelay\n        })\n      ]).start(({finished}) => {\n        if (finished) {\n          this.hasFinishedFirstLoop = true\n        }\n        if (loop) {\n          this.animateBounce()\n        }\n      })\n    }, this.hasFinishedFirstLoop ? bounceDelay > 0 ? bounceDelay : 0 : marqueeDelay)\n  }\n\n  start = async () => {\n    this.setState({ animating: true })\n    this.setTimeout(async () => {\n      await this.calculateMetrics()\n      if (!this.state.contentFits) {\n        const {onScrollStart} = this.props\n        if(onScrollStart && typeof onScrollStart === \"function\") {\n          onScrollStart()\n        }\n        if (this.props.animationType === 'auto') {\n          if (this.state.shouldBounce && this.props.bounce) {\n            this.animateBounce()\n          } else {\n            this.animateScroll()\n          }\n        } else if (this.props.animationType === 'bounce') {\n          this.animateBounce()\n        } else if (this.props.animationType === 'scroll') {\n          this.animateScroll()\n        }\n      }\n    }, 100)\n  }\n\n  stopAnimation() {\n    this.animatedValue.setValue(0)\n    this.setState({ animating: false, shouldBounce: false })\n  }\n\n  async calculateMetrics() {\n    const {shouldAnimateTreshold} = this.props\n    this.calculateMetricsPromise = this.makeCancelable(new Promise(async (resolve, reject) => {\n      try {\n        const measureWidth = node =>\n          new Promise(async (resolve, reject) => {\n            // nodehandle is not always there, causes crash. modified to check..\n            const nodeHandle = findNodeHandle(node);\n            if (nodeHandle) {\n              UIManager.measure(nodeHandle, (x, y, w) => {\n                // console.log('Width: ' + w)\n                return resolve(w)\n              })\n            } else {\n              return reject('nodehandle_not_found');\n            }\n          });\n        const [containerWidth, textWidth] = await Promise.all([\n          measureWidth(this.containerRef),\n          measureWidth(this.textRef)\n        ]);\n\n        this.containerWidth = containerWidth\n        this.textWidth = textWidth\n        this.distance = textWidth - containerWidth + shouldAnimateTreshold\n\n        // console.log(`distance: ${this.distance}, contentFits: ${this.state.contentFits}`)\n        resolve({\n          // Is 1 instead of 0 to get round rounding errors from:\n          // https://github.com/facebook/react-native/commit/a534672\n          contentFits:  this.distance <= 1,\n          shouldBounce: this.distance < this.containerWidth / 8\n        })\n      } catch (error) {\n        console.warn('react-native-text-ticker: could not calculate metrics', error);\n      }\n    }))\n    await this.calculateMetricsPromise.then((result) => {\n      this.setState({\n        contentFits: result.contentFits,\n        shouldBounce: result.shouldBounce,\n      })\n      return []\n    })\n  }\n\n  invalidateMetrics = () => {\n    this.distance = null\n    this.setState({ contentFits: true })\n  }\n\n  clearTimeout() {\n    if (this.timer) {\n      clearTimeout(this.timer)\n      this.timer = null\n    }\n  }\n\n  setTimeout(fn, time = 0) {\n    this.clearTimeout()\n    this.timer = setTimeout(fn, time)\n  }\n\n  scrollBegin = () => {\n    this.setState({ isScrolling: true })\n    this.animatedValue.setValue(0)\n  }\n\n  scrollEnd = () => {\n    const { marqueeDelay } = this.props\n    \n    this.setTimeout(() => {\n      this.setState({ isScrolling: false })\n      this.start()\n    }, marqueeDelay >= 0 ? marqueeDelay : 3000)\n  }\n\n  resetScroll = () => {\n    this.scrollBegin()\n    this.scrollEnd()\n  }\n\n  render() {\n    const { style, children, repeatSpacer, scroll, shouldAnimateTreshold, disabled, isRTL, ... props } = this.props\n    const { animating, contentFits, isScrolling } = this.state\n    const additionalContainerStyle = {\n      // This is useful for shouldAnimateTreshold only:\n      // we use flex: 1 to make the container take all the width available\n      // without this, if the children have a width smaller that this component's parent's,\n      // the container would have the width of the children (the text)\n      // In this case, it would be impossible to determine if animating is necessary based on the width of the container\n      // (contentFits in calculateMetrics() would always be true)\n      flex: shouldAnimateTreshold ? 1 : undefined\n    }\n    const animatedText = disabled ? null : (\n      <ScrollView\n        ref={c => (this.containerRef = c)}\n        horizontal\n        scrollEnabled={scroll ? !this.state.contentFits : false}\n        scrollEventThrottle={16}\n        onScrollBeginDrag={this.scrollBegin}\n        onScrollEndDrag={this.scrollEnd}\n        showsHorizontalScrollIndicator={false}\n        style={[StyleSheet.absoluteFillObject, (isRTL ?? I18nManager.isRTL) && { flexDirection: 'row-reverse' } ]}\n        display={animating ? 'flex' : 'none'}\n        onContentSizeChange={() => this.calculateMetrics()}\n      >\n        <Animated.Text\n          ref={c => (this.textRef = c)}\n          numberOfLines={1}\n          {... props}\n          style={[style, { transform: [{ translateX: this.animatedValue }], width: null }]}\n        >\n          {this.props.children}\n        </Animated.Text>\n        {!contentFits && !isScrolling\n          ? <View style={{ paddingLeft: repeatSpacer }}>\n            <Animated.Text\n              numberOfLines={1}\n              {... props}\n              style={[style, { transform: [{ translateX: this.animatedValue }], width: null }]}\n            >\n              {this.props.children}\n            </Animated.Text>\n          </View> : null }\n      </ScrollView>\n    );\n    return (\n      <View style={[styles.container, additionalContainerStyle]}>\n        <Text\n          {...props}\n          numberOfLines={1}\n          style={[style, { opacity: !disabled && animating ? 0 : 1 }]}\n        >\n          {this.props.children}\n        </Text>\n        {animatedText}\n      </View>\n    )\n  }\n\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden'\n  }\n})\n"]},"metadata":{},"sourceType":"module"}