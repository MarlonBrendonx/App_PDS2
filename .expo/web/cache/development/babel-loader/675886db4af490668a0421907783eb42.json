{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport { DEVICE_CONNECTIVITY_EVENT } from \"./privateTypes\";\nimport { NetInfoStateType, NetInfoCellularGeneration } from \"./types\";\nvar connection = window.navigator.connection || window.navigator.mozConnection || window.navigator.webkitConnection;\nvar typeMapping = {\n  bluetooth: NetInfoStateType.bluetooth,\n  cellular: NetInfoStateType.cellular,\n  ethernet: NetInfoStateType.ethernet,\n  none: NetInfoStateType.none,\n  other: NetInfoStateType.other,\n  unknown: NetInfoStateType.unknown,\n  wifi: NetInfoStateType.wifi,\n  wimax: NetInfoStateType.wimax,\n  mixed: NetInfoStateType.other\n};\nvar effectiveTypeMapping = {\n  '2g': NetInfoCellularGeneration['2g'],\n  '3g': NetInfoCellularGeneration['3g'],\n  '4g': NetInfoCellularGeneration['4g'],\n  'slow-2g': NetInfoCellularGeneration['2g']\n};\n\nvar _getCurrentState = function getCurrentState(_requestedInterface) {\n  var isConnected = navigator.onLine;\n  var baseState = {\n    isInternetReachable: null\n  };\n\n  if (!connection) {\n    if (isConnected) {\n      var _state2 = _objectSpread({}, baseState, {\n        isConnected: true,\n        type: NetInfoStateType.other,\n        details: {\n          isConnectionExpensive: false\n        }\n      });\n\n      return _state2;\n    }\n\n    var _state = _objectSpread({}, baseState, {\n      isConnected: false,\n      isInternetReachable: false,\n      type: NetInfoStateType.none,\n      details: null\n    });\n\n    return _state;\n  }\n\n  var isConnectionExpensive = connection.saveData;\n  var type = connection.type ? typeMapping[connection.type] : isConnected ? NetInfoStateType.other : NetInfoStateType.unknown;\n\n  if (type === NetInfoStateType.bluetooth) {\n    var _state3 = _objectSpread({}, baseState, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive\n      }\n    });\n\n    return _state3;\n  } else if (type === NetInfoStateType.cellular) {\n    var _state4 = _objectSpread({}, baseState, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        cellularGeneration: effectiveTypeMapping[connection.effectiveType] || null,\n        carrier: null\n      }\n    });\n\n    return _state4;\n  } else if (type === NetInfoStateType.ethernet) {\n    var _state5 = _objectSpread({}, baseState, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        ipAddress: null,\n        subnet: null\n      }\n    });\n\n    return _state5;\n  } else if (type === NetInfoStateType.wifi) {\n    var _state6 = _objectSpread({}, baseState, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive,\n        ssid: null,\n        bssid: null,\n        strength: null,\n        ipAddress: null,\n        subnet: null,\n        frequency: null\n      }\n    });\n\n    return _state6;\n  } else if (type === NetInfoStateType.wimax) {\n    var _state7 = _objectSpread({}, baseState, {\n      isConnected: true,\n      type: type,\n      details: {\n        isConnectionExpensive: isConnectionExpensive\n      }\n    });\n\n    return _state7;\n  } else if (type === NetInfoStateType.none) {\n    var _state8 = _objectSpread({}, baseState, {\n      isConnected: false,\n      isInternetReachable: false,\n      type: type,\n      details: null\n    });\n\n    return _state8;\n  } else if (type === NetInfoStateType.unknown) {\n    var _state9 = _objectSpread({}, baseState, {\n      isConnected: null,\n      isInternetReachable: null,\n      type: type,\n      details: null\n    });\n\n    return _state9;\n  }\n\n  var state = _objectSpread({}, baseState, {\n    isConnected: true,\n    type: NetInfoStateType.other,\n    details: {\n      isConnectionExpensive: isConnectionExpensive\n    }\n  });\n\n  return state;\n};\n\nvar handlers = [];\nvar nativeHandlers = [];\nvar RNCNetInfo = {\n  addListener: function addListener(type, handler) {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT:\n        {\n          var nativeHandler = function nativeHandler() {\n            handler(_getCurrentState());\n          };\n\n          if (connection) {\n            connection.addEventListener('change', nativeHandler);\n          } else {\n            window.addEventListener('online', nativeHandler, false);\n            window.addEventListener('offline', nativeHandler, false);\n          }\n\n          handlers.push(handler);\n          nativeHandlers.push(nativeHandler);\n          break;\n        }\n    }\n  },\n  removeListeners: function removeListeners(type, handler) {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT:\n        {\n          var index = handlers.indexOf(handler);\n          var nativeHandler = nativeHandlers[index];\n\n          if (connection) {\n            connection.removeEventListener('change', nativeHandler);\n          } else {\n            window.addEventListener('online', nativeHandler);\n            window.addEventListener('offline', nativeHandler);\n          }\n\n          handlers.splice(index, 1);\n          nativeHandlers.splice(index, 1);\n          break;\n        }\n    }\n  },\n  getCurrentState: function getCurrentState(requestedInterface) {\n    return _regeneratorRuntime.async(function getCurrentState$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", _getCurrentState(requestedInterface));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, this);\n  }\n};\nexport default RNCNetInfo;","map":{"version":3,"sources":["nativeModule.web.ts"],"names":["connection","window","typeMapping","bluetooth","NetInfoStateType","cellular","ethernet","none","other","unknown","wifi","wimax","mixed","effectiveTypeMapping","NetInfoCellularGeneration","getCurrentState","isConnected","navigator","baseState","isInternetReachable","state","type","details","isConnectionExpensive","cellularGeneration","carrier","ipAddress","subnet","ssid","bssid","strength","frequency","handlers","nativeHandlers","RNCNetInfo","addListener","nativeHandler","handler","removeListeners","index"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {\n  NetInfoNativeModule,\n  DEVICE_CONNECTIVITY_EVENT,\n  NetInfoNativeModuleState,\n} from './privateTypes';\nimport {\n  NetInfoState,\n  NetInfoStateType,\n  NetInfoUnknownState,\n  NetInfoNoConnectionState,\n  NetInfoCellularState,\n  NetInfoBluetoothState,\n  NetInfoEthernetState,\n  NetInfoWifiState,\n  NetInfoWimaxState,\n  NetInfoOtherState,\n  NetInfoCellularGeneration,\n} from './types';\n\n// See https://wicg.github.io/netinfo/#dom-connectiontype\ntype ConnectionType =\n  | 'bluetooth'\n  | 'cellular'\n  | 'ethernet'\n  | 'mixed'\n  | 'none'\n  | 'other'\n  | 'unknown'\n  | 'wifi'\n  | 'wimax';\n\n// See https://wicg.github.io/netinfo/#dom-effectiveconnectiontype\ntype ConnectionEffectiveType = '2g' | '3g' | '4g' | 'slow-2g';\n\n// https://wicg.github.io/netinfo/#dom-networkinformation-savedata\ntype ConnectionSaveData = boolean;\n\ninterface Events {\n  change: Event;\n}\n\ninterface Connection {\n  type: ConnectionType;\n  effectiveType: ConnectionEffectiveType;\n  saveData: ConnectionSaveData;\n  addEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[K]) => void,\n  ): void;\n}\n\n// Create (optional) connection APIs on navigator\ndeclare global {\n  interface Navigator {\n    connection?: Connection;\n    mozConnection?: Connection;\n    webkitConnection?: Connection;\n  }\n}\n\n// Check if the browser supports the connection API\nconst connection =\n  window.navigator.connection ||\n  window.navigator.mozConnection ||\n  window.navigator.webkitConnection;\n\n// Map browser types to native types\nconst typeMapping: Record<ConnectionType, NetInfoStateType> = {\n  bluetooth: NetInfoStateType.bluetooth,\n  cellular: NetInfoStateType.cellular,\n  ethernet: NetInfoStateType.ethernet,\n  none: NetInfoStateType.none,\n  other: NetInfoStateType.other,\n  unknown: NetInfoStateType.unknown,\n  wifi: NetInfoStateType.wifi,\n  wimax: NetInfoStateType.wimax,\n  mixed: NetInfoStateType.other,\n};\nconst effectiveTypeMapping: Record<\n  ConnectionEffectiveType,\n  NetInfoCellularGeneration\n> = {\n  '2g': NetInfoCellularGeneration['2g'],\n  '3g': NetInfoCellularGeneration['3g'],\n  '4g': NetInfoCellularGeneration['4g'],\n  'slow-2g': NetInfoCellularGeneration['2g'],\n};\n\n// Determine current state of connection\nconst getCurrentState = (\n  _requestedInterface?: string,\n): Pick<NetInfoState, Exclude<keyof NetInfoState, 'isInternetReachable'>> => {\n  const isConnected = navigator.onLine;\n  const baseState = {\n    isInternetReachable: null,\n  };\n\n  // If we don't have a connection object, we return minimal information\n  if (!connection) {\n    if (isConnected) {\n      const state: NetInfoOtherState = {\n        ...baseState,\n        isConnected: true,\n        type: NetInfoStateType.other,\n        details: {\n          isConnectionExpensive: false,\n        },\n      };\n      return state;\n    }\n\n    const state: NetInfoNoConnectionState = {\n      ...baseState,\n      isConnected: false,\n      isInternetReachable: false,\n      type: NetInfoStateType.none,\n      details: null,\n    };\n    return state;\n  }\n\n  // Otherwise try to return detailed information\n  const isConnectionExpensive = connection.saveData;\n  const type: NetInfoStateType = connection.type\n    ? typeMapping[connection.type]\n    : isConnected\n    ? NetInfoStateType.other\n    : NetInfoStateType.unknown;\n\n  if (type === NetInfoStateType.bluetooth) {\n    const state: NetInfoBluetoothState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.cellular) {\n    const state: NetInfoCellularState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        cellularGeneration:\n          effectiveTypeMapping[connection.effectiveType] || null,\n        carrier: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.ethernet) {\n    const state: NetInfoEthernetState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        ipAddress: null,\n        subnet: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.wifi) {\n    const state: NetInfoWifiState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n        ssid: null,\n        bssid: null,\n        strength: null,\n        ipAddress: null,\n        subnet: null,\n        frequency: null,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.wimax) {\n    const state: NetInfoWimaxState = {\n      ...baseState,\n      isConnected: true,\n      type,\n      details: {\n        isConnectionExpensive,\n      },\n    };\n    return state;\n  } else if (type === NetInfoStateType.none) {\n    const state: NetInfoNoConnectionState = {\n      ...baseState,\n      isConnected: false,\n      isInternetReachable: false,\n      type,\n      details: null,\n    };\n    return state;\n  } else if (type === NetInfoStateType.unknown) {\n    const state: NetInfoUnknownState = {\n      ...baseState,\n      isConnected: null,\n      isInternetReachable: null,\n      type,\n      details: null,\n    };\n    return state;\n  }\n\n  const state: NetInfoOtherState = {\n    ...baseState,\n    isConnected: true,\n    type: NetInfoStateType.other,\n    details: {\n      isConnectionExpensive,\n    },\n  };\n  return state;\n};\n\nconst handlers: ((state: NetInfoNativeModuleState) => void)[] = [];\nconst nativeHandlers: (() => void)[] = [];\n\nconst RNCNetInfo: NetInfoNativeModule = {\n  addListener(type, handler): void {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT: {\n        const nativeHandler = (): void => {\n          handler(getCurrentState());\n        };\n\n        if (connection) {\n          connection.addEventListener('change', nativeHandler);\n        } else {\n          window.addEventListener('online', nativeHandler, false);\n          window.addEventListener('offline', nativeHandler, false);\n        }\n\n        // Remember handlers\n        handlers.push(handler);\n        nativeHandlers.push(nativeHandler);\n\n        break;\n      }\n    }\n  },\n\n  removeListeners(type, handler): void {\n    switch (type) {\n      case DEVICE_CONNECTIVITY_EVENT: {\n        // Get native handler\n        const index = handlers.indexOf(handler);\n        const nativeHandler = nativeHandlers[index];\n\n        if (connection) {\n          connection.removeEventListener('change', nativeHandler);\n        } else {\n          window.addEventListener('online', nativeHandler);\n          window.addEventListener('offline', nativeHandler);\n        }\n\n        // Remove handlers\n        handlers.splice(index, 1);\n        nativeHandlers.splice(index, 1);\n\n        break;\n      }\n    }\n  },\n\n  async getCurrentState(requestedInterface): Promise<NetInfoNativeModuleState> {\n    return getCurrentState(requestedInterface);\n  },\n};\n\nexport default RNCNetInfo;\n"]},"metadata":{},"sourceType":"module"}